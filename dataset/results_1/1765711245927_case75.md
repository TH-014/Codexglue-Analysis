# Case 75

### Real verdict: 1
### Commit Id: 072be3e8969f24113d599444be4d6a0ed04a6602

## Prompt:

"""Given a source code, the task is to identify whether it is an insecure code that may attack software systems, such as resource leaks, use-after-free vulnerabilities and DoS attack.  Treat the task as binary classification (0/1), where 1 stands for insecure code and 0 for secure code.

```
int ff_h264_decode_seq_parameter_set(H264Context *h){

    MpegEncContext * const s = &h->s;

    int profile_idc, level_idc, constraint_set_flags = 0;

    unsigned int sps_id;

    int i, log2_max_frame_num_minus4;

    SPS *sps;



    profile_idc= get_bits(&s->gb, 8);

    constraint_set_flags |= get_bits1(&s->gb) << 0;   //constraint_set0_flag

    constraint_set_flags |= get_bits1(&s->gb) << 1;   //constraint_set1_flag

    constraint_set_flags |= get_bits1(&s->gb) << 2;   //constraint_set2_flag

    constraint_set_flags |= get_bits1(&s->gb) << 3;   //constraint_set3_flag

    get_bits(&s->gb, 4); // reserved

    level_idc= get_bits(&s->gb, 8);

    sps_id= get_ue_golomb_31(&s->gb);



    if(sps_id >= MAX_SPS_COUNT) {

        av_log(h->s.avctx, AV_LOG_ERROR, "sps_id (%d) out of range\n", sps_id);

        return -1;

    }

    sps= av_mallocz(sizeof(SPS));

    if(sps == NULL)

        return -1;



    sps->time_offset_length = 24;

    sps->profile_idc= profile_idc;

    sps->constraint_set_flags = constraint_set_flags;

    sps->level_idc= level_idc;



    memset(sps->scaling_matrix4, 16, sizeof(sps->scaling_matrix4));

    memset(sps->scaling_matrix8, 16, sizeof(sps->scaling_matrix8));

    sps->scaling_matrix_present = 0;



    if(sps->profile_idc >= 100){ //high profile

        sps->chroma_format_idc= get_ue_golomb_31(&s->gb);

        if(sps->chroma_format_idc > 3) {

            av_log(h->s.avctx, AV_LOG_ERROR, "chroma_format_idc (%u) out of range\n", sps->chroma_format_idc);

            goto fail;

        } else if(sps->chroma_format_idc == 3) {

            sps->residual_color_transform_flag = get_bits1(&s->gb);

        }

        sps->bit_depth_luma   = get_ue_golomb(&s->gb) + 8;

        sps->bit_depth_chroma = get_ue_golomb(&s->gb) + 8;

        sps->transform_bypass = get_bits1(&s->gb);

        decode_scaling_matrices(h, sps, NULL, 1, sps->scaling_matrix4, sps->scaling_matrix8);

    }else{

        sps->chroma_format_idc= 1;

        sps->bit_depth_luma   = 8;

        sps->bit_depth_chroma = 8;

    }



    log2_max_frame_num_minus4 = get_ue_golomb(&s->gb);

    if (log2_max_frame_num_minus4 < MIN_LOG2_MAX_FRAME_NUM - 4 ||

        log2_max_frame_num_minus4 > MAX_LOG2_MAX_FRAME_NUM - 4) {

        av_log(h->s.avctx, AV_LOG_ERROR,

               "log2_max_frame_num_minus4 out of range (0-12): %d\n",

               log2_max_frame_num_minus4);

        return AVERROR_INVALIDDATA;

    }

    sps->log2_max_frame_num = log2_max_frame_num_minus4 + 4;



    sps->poc_type= get_ue_golomb_31(&s->gb);



    if(sps->poc_type == 0){ //FIXME #define

        sps->log2_max_poc_lsb= get_ue_golomb(&s->gb) + 4;

    } else if(sps->poc_type == 1){//FIXME #define

        sps->delta_pic_order_always_zero_flag= get_bits1(&s->gb);

        sps->offset_for_non_ref_pic= get_se_golomb(&s->gb);

        sps->offset_for_top_to_bottom_field= get_se_golomb(&s->gb);

        sps->poc_cycle_length                = get_ue_golomb(&s->gb);



        if((unsigned)sps->poc_cycle_length >= FF_ARRAY_ELEMS(sps->offset_for_ref_frame)){

            av_log(h->s.avctx, AV_LOG_ERROR, "poc_cycle_length overflow %u\n", sps->poc_cycle_length);

            goto fail;

        }



        for(i=0; i<sps->poc_cycle_length; i++)

            sps->offset_for_ref_frame[i]= get_se_golomb(&s->gb);

    }else if(sps->poc_type != 2){

        av_log(h->s.avctx, AV_LOG_ERROR, "illegal POC type %d\n", sps->poc_type);

        goto fail;

    }



    sps->ref_frame_count= get_ue_golomb_31(&s->gb);

    if(sps->ref_frame_count > MAX_PICTURE_COUNT-2 || sps->ref_frame_count >= 32U){

        av_log(h->s.avctx, AV_LOG_ERROR, "too many reference frames\n");

        goto fail;

    }

    sps->gaps_in_frame_num_allowed_flag= get_bits1(&s->gb);

    sps->mb_width = get_ue_golomb(&s->gb) + 1;

    sps->mb_height= get_ue_golomb(&s->gb) + 1;

    if((unsigned)sps->mb_width >= INT_MAX/16 || (unsigned)sps->mb_height >= INT_MAX/16 ||

       av_image_check_size(16*sps->mb_width, 16*sps->mb_height, 0, h->s.avctx)){

        av_log(h->s.avctx, AV_LOG_ERROR, "mb_width/height overflow\n");

        goto fail;

    }



    sps->frame_mbs_only_flag= get_bits1(&s->gb);

    if(!sps->frame_mbs_only_flag)

        sps->mb_aff= get_bits1(&s->gb);

    else

        sps->mb_aff= 0;



    sps->direct_8x8_inference_flag= get_bits1(&s->gb);

    if(!sps->frame_mbs_only_flag && !sps->direct_8x8_inference_flag){

        av_log(h->s.avctx, AV_LOG_ERROR, "This stream was generated by a broken encoder, invalid 8x8 inference\n");

        goto fail;

    }



#ifndef ALLOW_INTERLACE

    if(sps->mb_aff)

        av_log(h->s.avctx, AV_LOG_ERROR, "MBAFF support not included; enable it at compile-time.\n");

#endif

    sps->crop= get_bits1(&s->gb);

    if(sps->crop){

        int crop_vertical_limit   = sps->chroma_format_idc  & 2 ? 16 : 8;

        int crop_horizontal_limit = sps->chroma_format_idc == 3 ? 16 : 8;

        sps->crop_left  = get_ue_golomb(&s->gb);

        sps->crop_right = get_ue_golomb(&s->gb);

        sps->crop_top   = get_ue_golomb(&s->gb);

        sps->crop_bottom= get_ue_golomb(&s->gb);

        if(sps->crop_left || sps->crop_top){

            av_log(h->s.avctx, AV_LOG_ERROR, "insane cropping not completely supported, this could look slightly wrong ...\n");

        }

        if(sps->crop_right >= crop_horizontal_limit || sps->crop_bottom >= crop_vertical_limit){

            av_log(h->s.avctx, AV_LOG_ERROR, "brainfart cropping not supported, this could look slightly wrong ...\n");

        }

    }else{

        sps->crop_left  =

        sps->crop_right =

        sps->crop_top   =

        sps->crop_bottom= 0;

    }



    sps->vui_parameters_present_flag= get_bits1(&s->gb);

    if( sps->vui_parameters_present_flag )

        if (decode_vui_parameters(h, sps) < 0)

            goto fail;



    if(!sps->sar.den)

        sps->sar.den= 1;



    if(s->avctx->debug&FF_DEBUG_PICT_INFO){

        static const char csp[4][5] = { "Gray", "420", "422", "444" };

        av_log(h->s.avctx, AV_LOG_DEBUG, "sps:%u profile:%d/%d poc:%d ref:%d %dx%d %s %s crop:%d/%d/%d/%d %s %s %d/%d\n",

               sps_id, sps->profile_idc, sps->level_idc,

               sps->poc_type,

               sps->ref_frame_count,

               sps->mb_width, sps->mb_height,

               sps->frame_mbs_only_flag ? "FRM" : (sps->mb_aff ? "MB-AFF" : "PIC-AFF"),

               sps->direct_8x8_inference_flag ? "8B8" : "",

               sps->crop_left, sps->crop_right,

               sps->crop_top, sps->crop_bottom,

               sps->vui_parameters_present_flag ? "VUI" : "",

               csp[sps->chroma_format_idc],

               sps->timing_info_present_flag ? sps->num_units_in_tick : 0,

               sps->timing_info_present_flag ? sps->time_scale : 0

               );

    }



    av_free(h->sps_buffers[sps_id]);

    h->sps_buffers[sps_id]= sps;

    h->sps = *sps;

    return 0;

fail:

    av_free(sps);

    return -1;

}

```

Output Format:
```
{
    "prediction": 1,
    "line no": <which line causes the threat>,
    "explanation": "----<explain why you classify this as insecure>------"
}
```

or

```
{
    "prediction": 0,
    "line no": 0,
    "explanation": "<how is this secure>"
}
```

Strictly follow this output format."""


## Response:

```json
{
    "prediction": 1,
    "line no": 15,
    "explanation": "The function does not check if the allocation of 'sps' was successful before using it. If av_mallocz fails, 'sps' will be NULL, leading to potential dereferencing of NULL later in the code and causing a crash. Proper error handling is missing, making this code insecure."
}
```

## Verdict matched?:  Yes
## Semgrep Report:
```
{
    "version": "1.146.0",
    "results": [],
    "errors": [],
    "paths": {
        "scanned": [
            "temp_scan_target.c"
        ]
    },
    "time": {
        "rules": [],
        "rules_parse_time": 0.9585599899291992,
        "profiling_times": {
            "config_time": 1.4313101768493652,
            "core_time": 1.1616733074188232,
            "ignores_time": 0.0008845329284667969,
            "total_time": 2.597144365310669
        },
        "parsing_time": {
            "total_time": 0.0,
            "per_file_time": {
                "mean": 0.0,
                "std_dev": 0.0
            },
            "very_slow_stats": {
                "time_ratio": 0.0,
                "count_ratio": 0.0
            },
            "very_slow_files": []
        },
        "scanning_time": {
            "total_time": 0.003773927688598633,
            "per_file_time": {
                "mean": 0.0012579758961995442,
                "std_dev": 2.5712007653863924e-07
            },
            "very_slow_stats": {
                "time_ratio": 0.0,
                "count_ratio": 0.0
            },
            "very_slow_files": []
        },
        "matching_time": {
            "total_time": 0.0,
            "per_file_and_rule_time": {
                "mean": 0.0,
                "std_dev": 0.0
            },
            "very_slow_stats": {
                "time_ratio": 0.0,
                "count_ratio": 0.0
            },
            "very_slow_rules_on_files": []
        },
        "tainting_time": {
            "total_time": 0.0,
            "per_def_and_rule_time": {
                "mean": 0.0,
                "std_dev": 0.0
            },
            "very_slow_stats": {
                "time_ratio": 0.0,
                "count_ratio": 0.0
            },
            "very_slow_rules_on_defs": []
        },
        "fixpoint_timeouts": [],
        "prefiltering": {
            "project_level_time": 0.0,
            "file_level_time": 0.0,
            "rules_with_project_prefilters_ratio": 0.0,
            "rules_with_file_prefilters_ratio": 1.0,
            "rules_selected_ratio": 0.018867924528301886,
            "rules_matched_ratio": 0.018867924528301886
        },
        "targets": [],
        "total_bytes": 0,
        "max_memory_bytes": 1118323968
    },
    "engine_requested": "OSS",
    "skipped_rules": [],
    "profiling_results": []
}
```


## Semgrep Response Summary

No vulnerabilities found by Semgrep.
